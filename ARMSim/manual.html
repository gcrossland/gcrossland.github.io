<HTML>
  <HEAD>
    <TITLE>ARMSim Manual</TITLE>
    <META name="author" content="Geoff Crossland">
  </HEAD>
  <BODY>
    <H1 align=center>ARMSim Manual:</H1>

    <H3>Contents:</H3>
    <DL>
      <DT><A href="#1">Overview</A></DT>
      <DD><A href="#1.1">Introduction</A><BR><A href="#1.2">Level of Support for the ARM Architecture</A><BR><A href="#1.4">Notes on the Use of Terminology</A></DD>
      <DT><A href="#2">Usage</A></DT>
      <DD><A href="#2.1">Invoking ARMSim</A></DD>
      <DT><A href="#3">Configuration</A></DT>
      <DD><A href="#3.1">Compile-Time Options</A><BR><A href="#3.2">Trace File Format</A></DD>
      <DT><A href="#a">Appendices</A></DT>
      <DD><A href="#a.a">Implementation Issues</A><BR><A href="#a.b">Build Configuration Settings</A></DD>
    </DL>

    <A name="1"><H2>Overview:</H2></A>

    <A name="1.1"><H3>Introduction:</H3></A>
    <P>ARMSim is a software simulation, written in C (and typically in something approaching ANSI C), of an ARM processor; it can be configured to either give you a three stage pipeline (comprising fetching, decoding and execution) typical of older cores or a superscalar, out-of-order pipeline. Output can be produced, in HTML format, at the end of each cycle.</P>

    <A name="1.2"><H3>Level of Support for the ARM Architecture:</H3></A>
    <P>The implementation of the instruction set is far from complete and it would be virtually impossible to run anything approximating an operating system under the simulator, but this is not the intent. ARMSim exists to demonstrate the effectiveness of various types of superscalar enhancement to an ARM core with respect to common user mode code and so that the author can see the virtual insides of a processor doing all that funky out-of-order stuff.</P>
    <P>It takes its implementation roughly from the ARMv3 set, but only includes a subset of the instructions, namely the data processing instructions, <CODE>MUL</CODE>, <CODE>MLA</CODE>, <CODE>B</CODE>, <CODE>BL</CODE>, <CODE>STR</CODE>, <CODE>LDR</CODE>, <CODE>STM</CODE>, and <CODE>LDM</CODE>. Only 32-bit and 8-bit memory operations are supported and the <CODE>SWP</CODE> instruction is not supported. There is no concept of multiple processor privilage levels and only 32-bit mode is present. There is no MMU, so logical addresses generated by instructions go straight out to memory (there is a virtual memory map which supports at least 31-bit addressing). There are no interrupts or exceptions and the vectors are meaningless, except for the reset vector (and the position of this can be changed). The PSR management instructions are missing and there are no coprocessors.</P>

    <A name="1.4"><H3>Notes on the Use of Terminology:</H3></A>
    <P>This file assumes a good knowledge of high performance computing techniques such as out-of-order execution. For those without such a grounding, there are a number of good articles on the subject around (these are all directly focused on the x86 architecture, although knowledege of, say, that architecture's assembly language is not a requirement). In any case, a reasonable grounding in machine code or assembly language for the ARM is assumed.</P>
    <UL>
      <LI>Volume 1, chapters 2.4 and 2.5 of the <A href="http://developer.intel.com/design/pentium4/manuals/245470.htm">Intel Architecture Software Developer's Manual</A>, for anything between the Pentium Pro and the Pentium III, give an introduction to the internals of a microarchitecture (the P6 core) pretty similar to the one simulated in ARMSim. Similarly, Appendix A of the <A href="http://www.amd.com/us-en/Processors/TechnicalResources/0,,30_182_739_2983,00.html">AMD Athlon Processor x86 Code Optimization Guide</A> does much the same for the K7 core (a core which works along much the same lines as the P6 core).</LI>
      <LI>Agner Fox has written <A href="http://www.agner.org/assem/pentopt.zip">a detailed article</A> on optimising assembly language code for the P6 core; it includes some fairly good explanations of some of the features that appear in ARMSim, namely register renaming (chapter 16.1), the reorder buffer (chapter 17), retirement (chapter 18) and branch prediction (chapters 22.1 and 22.2). Be prepared to move quickly on as soon as he starts talking about deeply x86-specific stuff, though, if that's not your cup of tea. Also, see <A href="http://www.x86.org/articles/branch/branchprediction.htm">his other article</A>, which is concerned with branch prediction.</LI>
      <LI>The final tome on these issues is Patterson and Hennessy's Computer Architecture: A Quantitative Approach. If the author were to produce a new version of ARMSim, it would be to implement some of the techniques in here not already covered.</LI>
    </UL>

    <A name="2"><H2>Usage:</H2></A>

    <A name="2.1"><H3>Invoking ARMSim:</H3></A>
    <P>The software runs through a command line interface, where you provide a source ROM file to use and the name of a directory in which the output files are to be created (unfortunately, since the ANSI C library does not provide the facility, you have to create the directory yourself). There are a number of other configuration options, to do with the output files; the switch <CODE>-h</CODE> lists all options and gives their descriptions and syntaces. By default, the simulator continues running indefinately, producing a set of output files for each cycle of the simulated processor. Errors are given should the software be unable to save out files (for example, should the disc become full or if the output file destination directory does not exist).</P>
    <P>The ROM file is treated as raw binary data and is loaded into the ARM's memory map at &amp;00000000; execution typically also begins there.</P>
    <P>The output is a collection of HTML files. Two files are created at the end of each cycle, one of the form <CITE>d</CITE>X<CITE>.htm</CITE> (the <CITE>d</CITE> stands for dynamic) and one of the form <CITE>s</CITE>X<CITE>.htm</CITE> (the <CITE>s</CITE> stands for static), where the variable is the hex index of the cycle. The static files give a display of the simulated processor at the end of the cycle and three buttons; one loads the static file for the previous cycle (with <CODE>accesskey</CODE> <KBD>B</KBD>), one loads the static file for the next cycle (with <CODE>accesskey</CODE> <KBD>F</KBD>) and one loads the dynamic file for the current cycle (with <CODE>accesskey</CODE> <KBD>S</KBD>). The dynamic files give the same processor data, but only have one button, which loads the static file from the current cycle (also with <CODE>accesskey</CODE> <KBD>S</KBD>). Also (assming your browser supports an HTTP refresh request in a <CODE>META</CODE> tag), every so often, the dynamic page for the next cycle will be loaded.</P>
    <P>The simulated processor is broken into a set of 'functional units', such as a decoder or an execution engine (the configuration of functional units is quite configurable, although it must be done at compile time). Each functional unit puts its output at one position on a grid. The output HTML contains a table of this grid and its elements.</P>

    <A name="3"><H2>Configuration:</H2></A>

    <A name="3.1"><H3>Compile-Time Options:</H3></A>
    <P>ARMSim is pretty configurable. It was initially built on a three stage pipeline and the superscalar implementation was created afterwards, although alongside it. Apart from the few options available on the command line, all configuration is done at compile time and made by creating and setting values to a set of constant macros in the configuration header file, <CITE>config.h</CITE>. Most of these are to do with setting up the precice format of the simulated processor, but a few are for other purposes. The statements to configure the simulated processor itself are given here.</P>
    <DL>
      <DT><CODE>ARM_HANDICAP</CODE></DT>
      <DD>This specifies the initial PC of the processor. The value must be word-aligned.</DD>
      <DT><CODE>ARM_LSU_BANDWIDTH</CODE></DT>
      <DD>This specifies the number of loads and/or stores the load/store unit can perform each cycle (both reads and writes from instructions and instruction fetches go through the LSU).</DD>
      <DT><CODE>ARM_BRANCHPRED</CODE></DT>
      <DD>If defined, this specifies the wayness of the associative branch target buffer mapping; if undefined, branch predition is disabled; <CODE>-1</CODE> indicates static prediction only (<CODE>AL</CODE> branches are always taken, <CODE>NV</CODE> branches are never taken and, otherwise, forward branches are not taken and backward branches are taken); <CODE>0</CODE> indicates that wayness is not being used (similar to 1-way, but the branches' addresses are not stored); direct mapping can be implemented by making the wayness equal to the number of entries. The value must be a power of 2.</DD>
      <DT><CODE>ARM_BRANCHPRED_ENTRIES</CODE></DT>
      <DD>This specifies the total number of branch target buffer entries. <CODE>ARM_BRANCHPRED</CODE> must divide this. The value must be a power of 2.</DD>
      <DT><CODE>ARM_BRANCHPRED_WAYASSOC_RANDOM</CODE><BR>
      <CODE>ARM_BRANCHPRED_WAYASSOC_LRU</CODE></DT>
      <DD>These specify the mechanism by which the branch prediction system allocates branch instruction data in the buffer when it is already full; with <CODE>ARM_BRANCHPRED_WAYASSOC_RANDOM</CODE>, one of the appropriate entries is chosen at random; with <CODE>ARM_BRANCHPRED_WAYASSOC_LRU</CODE> (which is misnamed), the least recently added way entry is replaced. Selecting neither will cause the system to, when the buffer is full, always replace the first entry.</DD>
      <DT><CODE>ARM_BRANCHPRED_DYNAMIC_STRONGEST_NOTTAKEN</CODE><BR>
      <CODE>ARM_BRANCHPRED_DYNAMIC_WEAKEST_NOTTAKEN</CODE><BR>
      <CODE>ARM_BRANCHPRED_DYNAMIC_WEAKEST_TAKEN</CODE><BR>
      <CODE>ARM_BRANCHPRED_DYNAMIC_STRONGEST_TAKEN</CODE></DT>
      <DD>Whenever a branch is taken, the value associated with it in the BPB is incremented (indicating that the system should consider the branch more likely to be taken in the future than it did before); similarly, a branch falling through triggers decrementation. These constants specify the ranges of values which instruct the system to either keep fetching from the current instruction stream or to move to the branch target. The values stored in the BPB are saturated at the limits of <CODE>ARM_BRANCHPRED_DYNAMIC_STRONGEST_NOTTAKEN</CODE> and <CODE>ARM_BRANCHPRED_DYNAMIC_STRONGEST_TAKEN</CODE>.<BR><EM>[ Note: the author was under the impression that any gap between the taken and not taken ranges would be left to the static predictor, but it appears that this is not the case; not taken is assumed if it is strictly less than <CODE>ARM_BRANCHPRED_DYNAMIC_WEAKEST_TAKEN</CODE>. ]</EM></DD>
      <DT><CODE>ARM_RETURNPRED</CODE></DT>
      <DD>If defined, this specifies the number of entries in the return prediction buffer; if undefined, return predition is disabled.<BR><EM>[ Note: return prediction has never worked very well, giving, at best, a yield of around 25% correct return predictions; the author has always suspected there to be a bug in the system (there were bugs producing a similar unexpected lack of effectiveness in the branch prediction system), especially since return prediction is such an easy deal (push a return value when you fetch an appropriate BL instruction and pull one off, to move the instruction fetching, when you fetch an appropriate <CODE>R15</CODE>-setting instruction), but has never been able to find one (it may be that the stack is becoming polluted by <CODE>BL</CODE>s which are fetched but are never executed, following a pipeline flush, but x86 return predictors don't seem to have any big problems; there's also the problem of what to do with conditional <CODE>BL</CODE>s and conditional returns). ]</EM></DD>
      <DT><CODE>ARM_SUPERSCALAR</CODE></DT>
      <DD>If defined, this specifies that the superscalar pipeline should be used; if undefined, the in-order three-stage pipeline is used instead. The in-order pipeline consists of an instruction fetch unit, a decoder and an execution unit.
      The standard superscalar pipeline has six stages and consists of an instruction fetch unit, a primary decoder, a secondary decoder and register renaming unit, a reorder buffer (which is a bit of a misnomer, since ARMSim's ROB doesn't actually swap instructions about in the unit), execution units and a retirement unit.</DD>
      <DT><CODE>ARM_SUPERSCALAR_SHORT</CODE></DT>
      <DD>If defined, this specifies that the short version superscalar pipeline should be used; the functionality of the primary decoder is moved into the following pipeline stage (this version was created to see what sort of differences in throughput could result from shaving off a pipeline stage). This requires <CODE>ARM_SUPERSCALAR</CODE>.</DD>
      <DT><CODE>ARM_SUPERSCALAR_FETCH</CODE></DT>
      <DD>This specifies the width of the instruction fetch unit, in terms of instructions i.e. the number of instructions it can fetch in a cycle. This is also the width of the decoding stage(s). This requires <CODE>ARM_SUPERSCALAR</CODE>.</DD>
      <DT><CODE>ARM_SUPERSCALAR_REGS</CODE></DT>
      <DD>This specifies the number of physical registers the processor has. ARM architectural registers are mapped to these by the register renaming unit; similarly, the ARM flags are represented as 'virtual' architectural registers (<CODE>R28</CODE> to <CODE>R31</CODE>, each containing one of the flags) and are also mapped to physical registers (this makes out-of-order execution possible even where instructions write to the flags). If the value is <CODE>20</CODE>, no renaming is performed. The value must be even. This requires <CODE>ARM_SUPERSCALAR</CODE>.</DD>
      <DT><CODE>ARM_SUPERSCALAR_ROB</CODE></DT>
      <DD>This specifies the number of instructions which can be held in the reorder buffer. It is members of this pool of instructions which may be issued to an execution unit. During and after execution, an instruction remains in the ROB until it is retired. This requires <CODE>ARM_SUPERSCALAR</CODE>.</DD>
      <DT><CODE>ARM_SUPERSCALAR_DATAPROC</CODE><BR>
      <CODE>ARM_SUPERSCALAR_MUL</CODE><BR>
      <CODE>ARM_SUPERSCALAR_SINGLEMEM</CODE><BR>
      <CODE>ARM_SUPERSCALAR_MULTIMEM</CODE><BR>
      <CODE>ARM_SUPERSCALAR_BRANCH</CODE><BR>
      <CODE>ARM_SUPERSCALAR_PSRTRANS</CODE></DT>
      <DD>These specify how many execution units exist for each type of instruction. <CODE>ARM_SUPERSCALAR_SINGLEMEM</CODE> units execute <CODE>LDR</CODE>s and <CODE>STR</CODE>s; <CODE>ARM_SUPERSCALAR_MULTIMEM</CODE> units execute <CODE>LDM</CODE>s and <CODE>STM</CODE>s; If <CODE>ARM_SUPERSCALAR_BRANCH</CODE> is <CODE>0</CODE>, the first <CODE>ARM_SUPERSCALAR_DATAPROC</CODE> unit is fed <CODE>B</CODE>s and <CODE>BL</CODE>s (in any case, writes to <CODE>R15</CODE> are processed always through <CODE>ARM_SUPERSCALAR_DATAPROC</CODE> units); <CODE>ARM_SUPERSCALAR_PSRTRANS</CODE> probably should be left as <CODE>0</CODE>, since <CODE>MRS</CODE> and <CODE>MSR</CODE> aren't implemented anyway. This requires <CODE>ARM_SUPERSCALAR</CODE>.</DD>
      <DT><CODE>ARM_SUPERSCALAR_RETIRE</CODE></DT>
      <DD>This specifies the width of the instruction retirement unit, in terms of instructions i.e. the number of instructions that can be retired in a cycle. Instructions are retired in order. The retirement unit maintains the architectural state of the processor and, when an instruction is retired, all values writen by it to physical registers are loaded into the appropriate ARM architectural registers (similarly, the architectural <CODE>R15</CODE> is appropriately incremented or changed). Hence, the architectural state is updated in order. This requires <CODE>ARM_SUPERSCALAR</CODE>.</DD>
      <DT><CODE>ARM_REGS_ALLOCATE_FROMTOP</CODE><BR>
      <CODE>ARM_REGS_ALLOCATE_CYCLIC</CODE></DT>
      <DD>These specify the algorthim used to grab free physical registers. <CODE>ARM_REGS_ALLOCATE_FROMTOP</CODE> starts with the last physical register and works downwards, using the first free register it finds (thus, the same physical registers tend to get used continually, while the remainder are typically dormant); <CODE>ARM_REGS_ALLOCATE_CYCLIC</CODE> searches from where the last physical register was allocated (it, thus, attempts to maximise the time between any given physical register being allocated and being allocated again). Unless there are exactly 20 physical registers, exactly one of these schemes must be defined. This requires <CODE>ARM_SUPERSCALAR</CODE>.</DD>
      <DT><CODE>ARM_ROB_SPECEXEC</CODE><BR>
      <CODE>ARM_ROB_SPECEXEC_R15READ</CODE><BR>
      <CODE>ARM_ROB_SPECEXEC_R15WRITE</CODE></DT>
      <DD>These specify to what extent instructions which are not certain to be executed may be executed anyway. Under <CODE>ARM_ROB_SPECEXEC</CODE>, instructions writing to registers only and not using <CODE>R15</CODE> may be executed even if they follow a branch the taking of which is not known (otherwise, they must wait until the branch has been retired before being executed). Under <CODE>ARM_ROB_SPECEXEC_R15READ</CODE>, instructions carry around with them a copy of their own <CODE>R15</CODE>, so instructions reading <CODE>R15</CODE> may now be executed out-of-order (otherwise, they must wait until all instructions ahead of them have been retired, so that the execution unit may examine the <CODE>R15</CODE> quoted in the architectural registers and get a value that is correct). Under <CODE>ARM_ROB_SPECEXEC_R15WRITE</CODE>, instructions writing to <CODE>R15</CODE> may now be executed out-of-order. Both <CODE>ARM_ROB_SPECEXEC_R15READ</CODE> and <CODE>ARM_ROB_SPECEXEC_R15WRITE</CODE> require <CODE>ARM_ROB_SPECEXEC</CODE>. This requires <CODE>ARM_SUPERSCALAR</CODE>.</DD>
      <DT><CODE>ARM_ROB_QUICKMEM</CODE></DT>
      <DD>This specifies that <CODE>LDR</CODE>s and <CODE>STR</CODE>s may be issued only a single cycle after preceeding <CODE>STR</CODE>s have been issued, without waiting for the store to complete (this is safe, because, while the <CODE>STR</CODE> will take two cycles to complete, the LSU request is made during the first cycle and the LSU performs memory operations in order of arrival). This requires <CODE>ARM_SUPERSCALAR</CODE>.</DD>
      <DT><CODE>ARM_MULTIMEM_BANDWIDTH</CODE></DT>
      <DD>This specifies the number of memory operations that <CODE>LDM</CODE>s and <CODE>STM</CODE>s may request of the LSU each cycle (the speed of response by the LSU is still bounded by <CODE>ARM_LSU_BANDWIDTH</CODE>, though).</DD>
    </DL>
    <P>A few additional values are provided for configuring the processor. The <CODE>SYSTEM_</CODE>*<CODE>_X</CODE> and <CODE>SYSTEM_</CODE>*<CODE>_Y</CODE> values may also be configured by the user. These specify, for each functional unit, the coordiates of the position on the output HTML grid where that functional unit produces its output (coordinates are zero-based and start from the top left, increasing down and right). Also, the control unit displays the contents of part of the ARM's memory map an this may be configured. The starting word address is given by <CODE>SYSTEM_CU_MEM_START</CODE> and the number of words is given by <CODE>SYSTEM_CU_MEM_WORDS</CODE>. Finally, if <CODE>ARM_TRACE_CHECK</CODE> is defined, ARMSim will check, after every cycle, the architectural state against a tracing file, the name of which is the value of <CODE>ARM_TRACE_CHECK</CODE> (a C string constant). If they do not match, an error is produced and the run is terminated.</P>

    <A name="3.2"><H3>Trace File Format:</H3></A>
    <P>ARMSim can read in an execution trace file as it goes and make sure that it produces results corresponding to those given. The file consists of a series of little endian, 32-bit two's complement values; these are grouped into frames of 16 values, giving the values of <CODE>R0</CODE> to <CODE>R15</CODE> at increasing addresses. Each frame gives the state immediately before an instruction, with <CODE>R15</CODE> pointing directly to that instruction. The initial state of the processor is taken to be with all registers &amp;00000000 and this gives the first frame (that which gives the state immediately before the instruction at the reset vector).</P>
    <P>The following table gives an example of an instruction stream at startup, with the values in the corresponding pre-instruction frames.</P>
    <TABLE border=1>
      <TR>
        <TH rowspan=2>Instruction</TH>
        <TH colspan=5>Trace Values</TH>
      </TR>
      <TR>
        <TH><CODE>R0</CODE></TH>
        <TH><CODE>R1</CODE></TH>
        <TH>...</TH>
        <TH><CODE>R14</CODE></TH>
        <TH><CODE>R15</CODE></TH>
      </TR>
      <TR>
        <TD>&nbsp;</TD>
        <TD><CODE>0</CODE></TD>
        <TD><CODE>0</CODE></TD>
        <TD>...</TD>
        <TD><CODE>0</CODE></TD>
        <TD><CODE>0</CODE></TD>
      </TR>
      <TR>
        <TD><CODE>MOV R0,#10</CODE></TD>
        <TD colspan=5>&nbsp;</TD>
      </TR>
      <TR>
        <TD colspan=6>&nbsp;</TD>
      </TR>
      <TR>
        <TD>&nbsp;</TD>
        <TD><CODE>10</CODE></TD>
        <TD><CODE>0</CODE></TD>
        <TD>...</TD>
        <TD><CODE>0</CODE></TD>
        <TD><CODE>4</CODE></TD>
      </TR>
      <TR>
        <TD><CODE>ADD R1,R0,R0</CODE></TD>
        <TD colspan=5>&nbsp;</TD>
      </TR>
      <TR>
        <TD colspan=6>&nbsp;</TD>
      </TR>
      <TR>
        <TD>&nbsp;</TD>
        <TD><CODE>10</CODE></TD>
        <TD><CODE>20</CODE></TD>
        <TD>...</TD>
        <TD><CODE>0</CODE></TD>
        <TD><CODE>8</CODE></TD>
      </TR>
      <TR>
        <TD><CODE>BL a_label</CODE></TD>
        <TD colspan=5>&nbsp;</TD>
      </TR>
      <TR>
        <TD colspan=6>&nbsp;</TD>
      </TR>
      <TR>
        <TD>&nbsp;</TD>
        <TD><CODE>10</CODE></TD>
        <TD><CODE>20</CODE></TD>
        <TD>...</TD>
        <TD><CODE>12</CODE></TD>
        <TD><CODE>a_label</CODE></TD>
      </TR>
      <TR>
        <TD><CODE>.a_label</CODE><BR><CODE>ADD R1,R1,R0</CODE></TD>
        <TD colspan=5>&nbsp;</TD>
      </TR>
      <TR>
        <TD colspan=6>&nbsp;</TD>
      </TR>
      <TR>
        <TD>&nbsp;</TD>
        <TD><CODE>10</CODE></TD>
        <TD><CODE>30</CODE></TD>
        <TD>...</TD>
        <TD><CODE>12</CODE></TD>
        <TD><CODE>a_label</CODE>+<CODE>4</CODE></TD>
      </TR>
      <TR>
        <TD><CODE>MOV R15,R14</CODE></TD>
        <TD colspan=5>&nbsp;</TD>
      </TR>
      <TR>
        <TD colspan=6>...</TD>
      </TR>
    </TABLE>

    <A name="a"><H2>Appendices:</H2></A>
    <A name="a.a"><H3>Implementation Issues:</H3></A>
    <P>There are a number of noteworthy issues concerning the source code and the structure of the simulated processor.<P>
    <UL>
      <LI><CODE>LDM</CODE>s and <CODE>STM</CODE>s stay as whole instructions throughout the superscalar pipeline. Since they at least quadruple the maximum number of standard ARM registers in an instruction (and, hence, vastly increase the number of bits required to represent an instruction in the execution engine), they would probably be split up into single-register loads and stores (or maybe double register operations, which would not increase the maximum number of registers). There would also be the benefit of completing loads for some registers earlier than with a monolithic instruction, allowing those values to be used straight away. Further, address generation for <CODE>LDR</CODE>s and <CODE>STR</CODE>s might be performed with seperate addition operations, as they are in current x86 cores.</LI>
      <LI>Both instructions and other data are fetched via a single load/store unit, which is atypical for a modern processor. Similarly, there are no memory caches simulated; all reads and writes are taken to happen over a single cycle; changing this would be a reasonably straightforward matter for a third party, because all memory access is directed through <CODE>system_lsu</CODE> (<CITE>memory.c</CITE>), but the author has no plans to do it himself (he did think about doing such a thing at the outset, but he doesn't now feel any particular drive to, since, although it would drastically improve the realism of the simulation, it couldn't increase the performance).</LI>
      <LI>Placement of functional units in the output files could be improved; similarly, some formats could be changed (e.g. turning a single column into two). The author has tried to do better on this score before, sticking with the idea that the pipeline should go left to right and functional units at the same stage should all appear in the same column, but never came up with anything that worked well. I think we're just stuck with huge pages of output, most of which is empty space. If you're prepared to recompile the software, feel free to play with it, though (see the compile-time configuration details).</LI>
      <LI>On a real processor, the functional units operate simultaneously during a cycle; in ARMSim, they are polled in turn (specifically, from the back to the front of the pipeline). Thus, some effects can have an extra latency of cycle above that which would be expected on a real processor; a few tricks are used to smooth this away sometimes (for example, for the purposes of polling, the LSU is taken to be right at the front of the pipeline, so memory requests from execution units reach it and are processed near the end of the cycle in which they are made and the values are waiting for the clients in the next cycle). The author has just realised that the way to both solve these problems and mirror more closely the way timing works inside a processor would be to split each cycle into multiple sub-cycles.</LI>
      <LI>There are a number of... er, caveats with the code.
        <UL>
          <LI>ARM 32-bit values are handled internally by a signed type, even when they are addresses, so using addresses with the top bit set is probably a bad idea.</LI>
          <LI>There are a number of internal counters (recording the number of instructions which have passed through and then ensuring that they are retired in the correct order, recording the order of requests arriving at the LSU and soforth) which may not get reset and do not properly handle wraparound at their greatest extents. Don't be surprised when, for example, the LSU goes tits up after about two billion requests.</LI>
          <LI>The output data caches used by the functional units are all of fixed size and no bounds checking is performed; this ensures best speed when creating output HTML text (it's got nothing to do with the author being lazy; perish the thought), but it does mean that the software will flip out seemingly randomly if a buffer is exceeded. <CODE>OUTPUT_SIZE</CODE>, in <CITE>main.c</CITE>, specifies the number of bytes in each buffer and is currently more than ample, but the world should have learned by now that speaking of a certain quantity of memory as being sufficient is just asking for trouble.</LI>
        </UL>
        I haven't done anything about these problems because I don't expect people will ever need them to be fixed (but do let the author know if you need them sorting).</LI>
    </UL>

    <A name="a.b"><H3>Build Configuration Settings:</H3></A>
    <P>The ARMSim source tree comes with config headers for four different configurations (named <CITE>config.h.</CITE>*), being the simple, simple with branch prediction, restrained superscalar and lavish superscalar configurations. These correspond with the compile-time settings given here.</P>
    <TABLE border=1>
      <TR>
        <TH rowspan=2>Configuration Constant</TH>
        <TH colspan=4>Build</TH>
      </TR>
      <TR>
        <TH>Simple</TH>
        <TH>Simple with Branch Prediction</TH>
        <TH>Restrained Superscalar</TH>
        <TH>Lavish Superscalar</TH>
      </TR>
      <TR>
        <TD><CODE>ARM_HANDICAP</CODE></TD>
        <TD><CODE>0</CODE></TD>
        <TD><CODE>0</CODE></TD>
        <TD><CODE>0</CODE></TD>
        <TD><CODE>0</CODE></TD>
      </TR>
      <TR>
        <TD><CODE>ARM_LSU_BANDWIDTH</CODE></TD>
        <TD><CODE>1</CODE></TD>
        <TD><CODE>1</CODE></TD>
        <TD><CODE>4</CODE></TD>
        <TD><CODE>8</CODE></TD>
      </TR>
      <TR>
        <TD><CODE>ARM_BRANCHPRED</CODE></TD>
        <TD rowspan=8>undefined</TD>
        <TD><CODE>4</CODE></TD>
        <TD><CODE>4</CODE></TD>
        <TD><CODE>8</CODE></TD>
      </TR>
      <TR>
        <TD><CODE>ARM_BRANCHPRED_ENTRIES</CODE></TD>
        <TD><CODE>32</CODE></TD>
        <TD><CODE>32</CODE></TD>
        <TD><CODE>128</CODE></TD>
      </TR>
      <TR>
        <TD><CODE>ARM_BRANCHPRED_WAYASSOC_LRU</CODE></TD>
        <TD>defined</TD>
        <TD>defined</TD>
        <TD>defined</TD>
      </TR>
      <TR>
        <TD><CODE>ARM_BRANCHPRED_DYNAMIC_STRONGEST_NOTTAKEN</CODE></TD>
        <TD><CODE>1</CODE></TD>
        <TD><CODE>1</CODE></TD>
        <TD><CODE>1</CODE></TD>
      </TR>
      <TR>
        <TD><CODE>ARM_BRANCHPRED_DYNAMIC_WEAKEST_NOTTAKEN</CODE></TD>
        <TD><CODE>1</CODE></TD>
        <TD><CODE>1</CODE></TD>
        <TD><CODE>1</CODE></TD>
      </TR>
      <TR>
        <TD><CODE>ARM_BRANCHPRED_DYNAMIC_WEAKEST_TAKEN</CODE></TD>
        <TD><CODE>2</CODE></TD>
        <TD><CODE>2</CODE></TD>
        <TD><CODE>2</CODE></TD>
      </TR>
      <TR>
        <TD><CODE>ARM_BRANCHPRED_DYNAMIC_STRONGEST_TAKEN</CODE></TD>
        <TD><CODE>3</CODE></TD>
        <TD><CODE>3</CODE></TD>
        <TD><CODE>3</CODE></TD>
      </TR>
      <TR>
        <TD><CODE>ARM_RETURNPRED</CODE></TD>
        <TD><CODE>8</CODE></TD>
        <TD><CODE>8</CODE></TD>
        <TD><CODE>16</CODE></TD>
      </TR>
      <TR>
        <TD><CODE>ARM_SUPERSCALAR</CODE></TD>
        <TD rowspan=17>undefined</TD>
        <TD rowspan=17>undefined</TD>
        <TD>defined</TD>
        <TD>defined</TD>
      </TR>
      <TR>
        <TD><CODE>ARM_SUPERSCALAR_SHORT</CODE></TD>
        <TD>undefined</TD>
        <TD>undefined</TD>
      </TR>
      <TR>
        <TD><CODE>ARM_SUPERSCALAR_FETCH</CODE></TD>
        <TD><CODE>2</CODE></TD>
        <TD><CODE>3</CODE></TD>
      </TR>
      <TR>
        <TD><CODE>ARM_SUPERSCALAR_REGS</CODE></TD>
        <TD><CODE>32</CODE></TD>
        <TD><CODE>64</CODE></TD>
      </TR>
      <TR>
        <TD><CODE>ARM_SUPERSCALAR_ROB</CODE></TD>
        <TD><CODE>32</CODE></TD>
        <TD><CODE>96</CODE></TD>
      </TR>
      <TR>
        <TD><CODE>ARM_SUPERSCALAR_DATAPROC</CODE></TD>
        <TD><CODE>1</CODE></TD>
        <TD><CODE>3</CODE></TD>
      </TR>
      <TR>
        <TD><CODE>ARM_SUPERSCALAR_MUL</CODE></TD>
        <TD><CODE>1</CODE></TD>
        <TD><CODE>2</CODE></TD>
      </TR>
      <TR>
        <TD><CODE>ARM_SUPERSCALAR_SINGLEMEM</CODE></TD>
        <TD><CODE>1</CODE></TD>
        <TD><CODE>2</CODE></TD>
      </TR>
      <TR>
        <TD><CODE>ARM_SUPERSCALAR_MULTIMEM</CODE></TD>
        <TD><CODE>1</CODE></TD>
        <TD><CODE>1</CODE></TD>
      </TR>
      <TR>
        <TD><CODE>ARM_SUPERSCALAR_BRANCH</CODE></TD>
        <TD><CODE>0</CODE></TD>
        <TD><CODE>0</CODE></TD>
      </TR>
      <TR>
        <TD><CODE>ARM_SUPERSCALAR_PSRTRANS</CODE></TD>
        <TD><CODE>0</CODE></TD>
        <TD><CODE>0</CODE></TD>
      </TR>
      <TR>
        <TD><CODE>ARM_SUPERSCALAR_RETIRE</CODE></TD>
        <TD><CODE>2</CODE></TD>
        <TD><CODE>3</CODE></TD>
      </TR>
      <TR>
        <TD><CODE>ARM_REGS_ALLOCATE_CYCLIC</CODE></TD>
        <TD rowspan=5>defined</TD>
        <TD rowspan=5>defined</TD>
      </TR>
      <TR>
        <TD><CODE>ARM_ROB_SPECEXEC</CODE></TD>
      </TR>
      <TR>
        <TD><CODE>ARM_ROB_SPECEXEC_R15READ</CODE></TD>
      </TR>
      <TR>
        <TD><CODE>ARM_ROB_SPECEXEC_R15WRITE</CODE></TD>
      </TR>
      <TR>
        <TD><CODE>ARM_ROB_QUICKMEM</CODE></TD>
      </TR>
      <TR>
        <TD><CODE>ARM_MULTIMEM_BANDWIDTH</CODE></TD>
        <TD><CODE>1</CODE></TD>
        <TD><CODE>1</CODE></TD>
        <TD><CODE>1</CODE></TD>
        <TD><CODE>3</CODE></TD>
      </TR>
      <TR>
        <TD><CODE>SYSTEM_CU_MEM_START</CODE></TD>
        <TD><CODE>&amp;02000000</CODE></TD>
        <TD><CODE>&amp;02000000</CODE></TD>
        <TD><CODE>&amp;02000000</CODE></TD>
        <TD><CODE>&amp;02000000</CODE></TD>
      </TR>
      <TR>
        <TD><CODE>SYSTEM_CU_MEM_WORDS</CODE></TD>
        <TD><CODE>64</CODE></TD>
        <TD><CODE>64</CODE></TD>
        <TD><CODE>64</CODE></TD>
        <TD><CODE>64</CODE></TD>
      </TR>
    </TABLE>
  </BODY>
</HTML>
